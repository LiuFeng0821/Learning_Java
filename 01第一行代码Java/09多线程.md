# 9 多线程

## 9.1 线程与进程
* 进程是程序的一次动态执行过程，它经历了从代码加载、执行到执行完毕的一个完整过程。
* 线程是在进程基础之上的进一步划分。

## 9.2 多线程的实现
* 在Java中，如果要想**实现多线程**，就必须依靠一个**线程的主体类**，这个主体类需要**继承Thread类或实现Runnable（Callable）接口**来完成定义。

* **java.lang.Thread类**是一个**负责线程操作**的类，任何类只要继承Thread类就可以成为一个线程的主类，线程启动的主方法需要覆写Thread类中的run()方法实现。
```java
class 类名称 extends Thread {
    属性;
    方法;
    public void run() {
        线程主体方法;
    }
}
```

* **多线程启动的唯一方法**就是**Thread类中的start()方法**,调用此方法执行的方法体就是run()方法中定义的代码：`public void start();`

Tips：实际上Java中真正**实现多线程**的是**start中的start0()方法**，run()方法只是一个普通方法。

* 使用**Thread类**可以方便多线程的实现，但是有**单继承**的问题，在Java中也可以**利用Runnable接口实现多线程**。
```java
@FunctionalInterface
public interface Runnable {
    public void run();
}
```

注意：虽然通过**实现Runnable接口**可以**覆写run()方法**，但是要**启动多线程**必须要**使用Thread类中的start()方法**才能完成，这时候可以利用**Thread类中的有参构造方法接收Runnable对象**来实现：`public Thread(Runable target)

```java
class MyThread implements Runnable{
	private String title;
	public MyThread(String title) {
		this.title = title;
	}
	public void run() {
		for (int x = 0;x < 5 ;x++ ){
			System.out.println(this.title + "--->" + x);
		}
	}
}
public class TestDemo{
	public static void main(String args[]) {
		MyThread m1 = new MyThread("线程1");
		MyThread m2 = new MyThread("线程2");
		MyThread m3 = new MyThread("线程3");
		new Thread(m1).start();
		new Thread(m2).start();
		new Thread(m3).start();
	}
}
```

* **Thread类是Runnable接口的子类，使用Runnable接口可以避免单继承局限，并且可以更加方便地实现数据共享的概念。**

* 虽然使用**Runnable接口**可以**避免单继承局限**，但是**Runnable接口里面的run()方法不能返回操作结果**，为了**解决这一问题**，JDK1.5开始，Java提供了一个新的接口：**java.util.concurrent.Callable**。
```java
@FunctionalInterface
public interface Callable<V> {
    public V call() throws Exception;
}
```

* 由于多线程需要利用Thread类来启动，但是Thread类中没有任何构造方法可以直接接收Callable接口对象实例，所以我们需要利用一个**java.util.concurrent.FutureTask<V>类**。
```java
public class FutureTask<V> 
extends Object
implements RunnableFuture<V>
```

FutureTask类继承结构如下图所示：

![9.2FutureTask类继承结构](image/9.2FutureTask%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png)

FutureTask类中的常用方法：
1. 接收Callable接口示例：`public FutureTask(Callable<V> callable)`
2. 接收Runnable接口实例，并指定返回结果类型：`public FutureTask(Runnable runnable,V result)`
3. 取得线程操作结果：`public V get() throws InterruptedException,ExecutionException`

利用Callable接口实现多线程例子：
```java
import java.util.concurrent.*;
class MyThread implements Callable<String>{
    private int ticket = 10;
    @Override
    public String call() throws Exception {
        for (int x = 0;x < 100;x++) {
            if (this.ticket > 0) {
                System.out.println("卖票，ticket = " + this.ticket--);
            }            
        }
        return "票已卖光！";
    }
}
public class TestDemo {
    public static void main(String args[]) throws Exception{
        MyThread m1 = new MyThread();
        MyThread m2 = new MyThread();
        FutureTask<String> task1 = new FutureTask<String>(m1);
        FutureTask<String> task2 = new FutureTask<String>(m2);
        new Thread(task1).start();
        new Thread(task2).start();
        System.out.println("A线程返回结果：" + task1.get());
        System.out.println("B线程返回结果：" + task2.get());
    }
}
```

任何**线程一般有五种状态**：
1. **创建状态**：在程序中**创建一个线程对象**之后，新的线程对象就处于**新建状态**，此时它已经有了对应的**内存空间**和**其他资源**，但是处于**不可运行状态**。
2. **就绪状态**：新建线程对象后，**调用线程的start()方法**就可以**启动线程**，当线程启动时，进入就绪状态，线程将进入**线程队列排队**，**等待CPU服务**。
3. **运行状态**：当就绪的线程**获得处理器资源**时，线程就进入了运行状态，会**自动调用线程对象的run()方法**。
4. **堵塞状态**：当**正在执行的线程**被**人为挂起**或者需要**执行耗时的输入输出操作**时，就**让出CPU**暂时中止自己的执行，如果**调用sleep()、suspend()、wait()等方法**，线程会进入堵塞状态。
5. **终止状态**：当**调用stop()方法**或者**run()方法执行结束**，会进入终止状态。

线程转换状态：

![线程转换状态](image/9.2%E7%BA%BF%E7%A8%8B%E8%BD%AC%E6%8D%A2%E7%8A%B6%E6%80%81.png)

## 9.3 多线程常用操作方法
* 取得当前线程对象的方法为：`public static Thread currentThread()`
* 实例化线程对象，接收Runnable接口子类对象，同时设置线程名称：`public Thread(Runnable target,String name)`
* 设置线程名字：`public void setName()`
* 取得线程名字：`public String getName()`

**每一个JVM就是一个进程**，每个JVM都**至少包含两个线程**：
* **main线程**：**程序的主要执行**，以及启动子线程。
* **gc线程**：负责**垃圾收集**。

* **线程的休眠**指的是让程序执行速度变慢一些，在**Thread类中线程休眠操作方法**为：`public static void sleep(long millis) throws InterruptedException`,**休眠单位是毫秒ms**。

* 在Java的线程操作中，所有的线程在运行前都会保持就绪状态，此时哪个线程优先级高，哪个线程就有可能会先被执行。

线程的优先级有如下几个操作：
1. 最高优先级，数值为10：`public static final int MAX_PRIORITY`
2. 中等优先级，数值为5：`public static final int NORM_PRIORITY`
3. 最低优先级，数值为1：`public static final int MIN_PRIORITY`
4. 设置线程优先级：`public final void setPriorty(int newPriority)`
5. 取得线程优先级：`public final int getPriority()`

## 9.4 线程的同步与死锁
同步问题的引出：
```java
class MyThread implements Runnable{
	private int ticket = 5;
	@Override
	public void run() {
		for (int x = 0;x < 20;x++){
			if (this.ticket > 0) {
				try {
					Thread.sleep(100);
				} catch (Exception e) {
					e.printStackTrace();
				}
				System.out.println(Thread.currentThread().getName() + ",ticket = " + this.ticket--);
			}
		}
	}
}
public class TestDemo{
	public static void main(String args[]) {
		MyThread mt = new MyThread();
		new Thread(mt,"票贩子A").start();
		new Thread(mt,"票贩子B").start();
		new Thread(mt,"票贩子C").start();
		new Thread(mt,"票贩子D").start();
	}
}
```

* **同步操作**就是**一个代码块**中的多个操作在**同一时间段**内**只能有一个线程进行**，**其他线程要等待**此线程完成后才可以继续执行。


在Java里面如果想要**实现线程的同步**，就可以使用**synchronized关键字**，可以通过以下两种方式实现调用：
1. **同步代码块**：利用**synchronized包装的代码块**，但是需要**指定同步对象**，**一般设置为this**。
2. **同步方法**：利用**synchronized定义的方法**。

* 当出现**共享数据**的概念的时候，就需要进行**同步处理**。
* 当一个线程进入一个对象的synchronized方法后，其他线程不可访问此对象的其他方法，因为**一个对象操作一个synchronized方法只能由一个线程访问**。

死锁的示例代码：
```java
class A{
	public synchronized void say(B b){
		System.out.println("A：你给我本，我给你笔，否则不给！");
		b.get();
	}
	public synchronized void get(){
		System.out.println("A：得到了本，付出了笔，一事无成！");
	}
}
class B{
	public synchronized void say(A a){
		System.out.println("B：你给我笔，我给你本，否则不给！");
		a.get();
	}
	public synchronized void get(){
		System.out.println("B：得到了笔，付出了本，一事无成！");
	}
}
public class TestDemo implements Runnable{
	private static A a = new A();
	private static B b = new B();
	public static void main(String args[]) throws Exception{
		new TestDemo();
	}
	public TestDemo(){
		new Thread(this).start();
		b.say(a);
	}
	public void run(){
		a.say(b);
	}
}
```

## 9.5 线程间的经典操作案例————生产者与消费者案例
为了避免死锁以及解决数据重复的问题，需要等待以及唤醒机制，可以依靠Object类来完成：
* 线程的等待：`public final void wait() throws InterruptedException`
* 唤醒第一个等待线程：`public final void notify()`
* 唤醒全部等待线程：`public final void notifyAll()`

生产者和消费者的示例代码：
```java
class Info{
	private String title;
	private String content;
	private boolean flag = true;
	public synchronized void set(String title,String content){
		if (this.flag == false){
			try{
				super.wait();
			} catch(Exception e){
				e.printStackTrace();
			}
		}
		this.title = title;
		try{
			Thread.sleep(100);
		}catch (Exception e){
			e.printStackTrace();
		}
		this.content = content;
		this.flag = false;
		super.notify();
	}
	public synchronized void get(){
		if (this.flag == true){
			try{
				super.wait();
			} catch(Exception e){
				e.printStackTrace();
			}
		}
		try{
			Thread.sleep(100);
		} catch(Exception e){
			e.printStackTrace();
		}
		System.out.println(this.title + "-->" + this.content);
		this.flag = true;
		super.notify();
	}
}
class Producter implements Runnable{
	private Info msg = null;
	public Producter(Info msg){
		this.msg = msg;
	}
	public void run(){
		for (int x = 0;x < 50;x++){
			if (x % 2 == 0){
				this.msg.set("Liu","Feng");
			} else{
				this.msg.set("Feng","Liu");
			}
		}
	}
}
class Consumer implements Runnable{
	private Info msg = null;
	public Consumer(Info msg){
		this.msg = msg;
	}
	public void run(){
		for (int x = 0;x < 50;x++){
			this.msg.get();
		}
	}
}
public class TestDemo{
	public static void main(String args[]){
		Info msg = new Info();
		new Thread(new Producter(msg)).start();
		new Thread(new Consumer(msg)).start();
	}
}
```

## 9.6 线程的生命周期

![线程的生命周期](image/)