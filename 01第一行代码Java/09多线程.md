# 9 多线程

## 9.1 线程与进程
* 进程是程序的一次动态执行过程，它经历了从代码加载、执行到执行完毕的一个完整过程。
* 线程是在进程基础之上的进一步划分。

## 9.2 多线程的实现
* 在Java中，如果要想**实现多线程**，就必须依靠一个**线程的主体类**，这个主体类需要**继承Thread类或实现Runnable（Callable）接口**来完成定义。

* **java.lang.Thread类**是一个**负责线程操作**的类，任何类只要继承Thread类就可以成为一个线程的主类，线程启动的主方法需要覆写Thread类中的run()方法实现。
```java
class 类名称 extends Thread {
    属性;
    方法;
    public void run() {
        线程主体方法;
    }
}
```

* **多线程启动的唯一方法**就是**Thread类中的start()方法**,调用此方法执行的方法体就是run()方法中定义的代码：`public void start();`

Tips：实际上Java中真正**实现多线程**的是**start中的start0()方法**，run()方法只是一个普通方法。

* 使用**Thread类**可以方便多线程的实现，但是有**单继承**的问题，在Java中也可以**利用Runnable接口实现多线程**。
```java
@FunctionalInterface
public interface Runnable {
    public void run();
}
```

注意：虽然通过**实现Runnable接口**可以**覆写run()方法**，但是要**启动多线程**必须要**使用Thread类中的start()方法**才能完成，这时候可以利用**Thread类中的有参构造方法接收Runnable对象**来实现：`public Thread(Runable target)

```java
class MyThread implements Runnable{
	private String title;
	public MyThread(String title) {
		this.title = title;
	}
	public void run() {
		for (int x = 0;x < 5 ;x++ ){
			System.out.println(this.title + "--->" + x);
		}
	}
}
public class TestDemo{
	public static void main(String args[]) {
		MyThread m1 = new MyThread("线程1");
		MyThread m2 = new MyThread("线程2");
		MyThread m3 = new MyThread("线程3");
		new Thread(m1).start();
		new Thread(m2).start();
		new Thread(m3).start();
	}
}
```

* **Thread类是Runnable接口的子类，使用Runnable接口可以避免单继承局限，并且可以更加方便地实现数据共享的概念。**

* 虽然使用**Runnable接口**可以**避免单继承局限**，但是**Runnable接口里面的run()方法不能返回操作结果**，为了**解决这一问题**，JDK1.5开始，Java提供了一个新的接口：**java.util.concurrent.Callable**。
```java
@FunctionalInterface
public interface Callable<V> {
    public V call() throws Exception;
}
```

* 由于多线程需要利用Thread类来启动，但是Thread类中没有任何构造方法可以直接接收Callable接口对象实例，所以我们需要利用一个java.util.concurrent.FutureTask<V>类。
```java
public class FutureTask<V> 
extends Object
implements RunnableFuture<V>
```

FutureTask类继承结构如下图所示：

![9.2FutureTask类继承结构](image/9.2FutureTask%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png)

FutureTask类中的常用方法：
1. 接收Callable接口示例：`public FutureTask(Callable<V> callable)`
2. 接收Runnable接口实例，并指定返回结果类型：`public FutureTask(Runnable runnable,V result)`
3. 取得线程操作结果：`public V get() throws InterruptedException,ExecutionException`

利用Callable接口实现多线程例子：
```java
import java.util.concurrent.*;
class MyThread implements Callable<String>{
    private int ticket = 10;
    @Override
    public String call() throws Exception {
        for (int x = 0;x < 100;x++) {
            if (this.ticket > 0) {
                System.out.println("卖票，ticket = " + this.ticket--);
            }            
        }
        return "票已卖光！";
    }
}
public class TestDemo {
    public static void main(String args[]) throws Exception{
        MyThread m1 = new MyThread();
        MyThread m2 = new MyThread();
        FutureTask<String> task1 = new FutureTask<String>(m1);
        FutureTask<String> task2 = new FutureTask<String>(m2);
        new Thread(task1).start();
        new Thread(task2).start();
        System.out.println("A线程返回结果：" + task1.get());
        System.out.println("B线程返回结果：" + task2.get());
    }
}
```

任何线程一般有五种状态：
1. 创建状态：在程序中创建一个线程对象之后，新的线程对象就处于新建状态，此时它已经有了对应的内存空间和其他资源，但是处于不可运行状态。
2. 就绪状态：新建线程对象后，调用线程的start()方法就可以启动线程，当线程启动时，进入就绪状态，线程将进入线程队列排队，等待CPU服务。
3. 运行状态：当就绪的线程获得处理器资源时，线程就进入了运行状态，会自动调用线程对象的run()方法。
4. 堵塞状态：当正在执行的线程被人为挂起或者需要执行耗时的输入输出操作时，就让出CPU暂时中止自己的执行，会调用sleep()、suspend()、wait()等方法，线程会进入堵塞状态。
5. 终止状态：当调用stop()方法或者run()方法执行结束，会进入终止状态。

线程转换状态：

![线程转换状态](image/9.2%E7%BA%BF%E7%A8%8B%E8%BD%AC%E6%8D%A2%E7%8A%B6%E6%80%81.png)

